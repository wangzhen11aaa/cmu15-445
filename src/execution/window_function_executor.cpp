#include "execution/executors/window_function_executor.h"
#include "execution/executors/sort_executor.h"
#include "execution/plans/window_plan.h"
#include "storage/table/tuple.h"
namespace bustub {

WindowFunctionExecutor::WindowFunctionExecutor(ExecutorContext *exec_ctx, const WindowFunctionPlanNode *plan,
                                               std::unique_ptr<AbstractExecutor> &&child_executor)
    : AbstractExecutor(exec_ctx), plan_(plan), child_executor_(std::move(child_executor)) {}

void WindowFunctionExecutor::Init() {
  Tuple read_tuple;
  RID read_rid;
  while (child_executor_->Next(&read_tuple, &read_rid)) {
    tuples_.push_back(read_tuple);
  }

  // Note: All window function aggregate the columns not generated by aggregation function.
  ValueComparator curr_comparator{};
  curr_comparator.schema_ = &plan_->OutputSchema();
  for (auto &[function_idx, window_function] : plan_->window_functions_) {
    // combine partition_by vector0 and order_by vector1 => vector0 + vector1
    std::vector<std::pair<OrderByType, AbstractExpressionRef>> total_orders{};
    std::vector<std::pair<OrderByType, AbstractExpressionRef>> partition_orders{};
    for (auto partition_by_ref : window_function.partition_by_) {
      total_orders.push_back({OrderByType::ASC, partition_by_ref});
      partition_orders.push_back({OrderByType::ASC, partition_by_ref});
    }
    for (auto order_by_ : window_function.order_by_) {
      total_orders.push_back(order_by_);
    }
    curr_comparator.SetOrderBy(&total_orders);
    // Sort
    auto it0 = tuples_.begin(), it1 = tuples_.end();
    std::sort(it0, it1, curr_comparator);

    auto aggre_expr = window_function.function_;

    WindowAggregate win_agg{plan_->columns_, aggre_expr, function_idx, window_function.type_, plan_->OutputSchema()};

    // 利用partition_orders来分割group
    curr_comparator.SetOrderBy(&partition_orders);
    it0 = tuples_.begin();
    while (it0 != tuples_.end()) {
      it1 = std::upper_bound(it0, tuples_.end(), *it0, curr_comparator);
      win_agg.Compute(it0, it1);
      it0 = it1;
    }
  }
  iter_ = tuples_.begin();
}

auto WindowFunctionExecutor::Next(Tuple *tuple, RID *rid) -> bool {
  while (iter_ != tuples_.end()) {
    *tuple = *iter_;
    iter_++;
    return true;
  }
  return false;
}
}  // namespace bustub
